<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>SELECT进阶 &#8212; MariaDB数据库教程 20240903 文档</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=12dfc556" />
    <script src="../_static/documentation_options.js?v=1254444f"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=beaddf03"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="prev" title="快速入门" href="beginner.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="select">
<h1>SELECT进阶<a class="headerlink" href="#select" title="Link to this heading">¶</a></h1>
<p>在此章节开始前，请确保你已学习过 <a class="reference internal" href="beginner.html"><span class="doc">快速入门</span></a> 中的内容。
在 <a class="reference internal" href="beginner.html"><span class="doc">快速入门</span></a> 中，我们使用了非常基础的 <strong>SELECT</strong> 语法去MariaDB中查询数据，
但随着数据表结构和数据量的变化，最基础的 <strong>SELECT</strong> 语法显然是无法满足需要的。因此从本节开始，我们将会探索 <strong>SELECT</strong> 语法中更高级的用法。</p>
<section id="id1">
<h2>基础要素<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h2>
<p>上一章，我们使用 <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">*</span> <span class="pre">FROM</span> <span class="pre">books;</span></code> 查询books表中的数据， <strong>*</strong> 表示选中所有字段进行查询，但是如果只想查询某一个或某几个字段呢？
此时只需要把 <strong>*</strong> 号，替换为需要查询的字段名（column）即可，多字段需要用 <strong>,</strong> 号隔开，请尝试运行以下的语句：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">Title</span><span class="p">,</span><span class="w"> </span><span class="n">AuthorID</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">books</span><span class="p">;</span>
</pre></div>
</div>
<img alt="../_images/3-1.png" class="align-center" src="../_images/3-1.png" />
<p>请观察上面的执行结果，与 <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">*</span> <span class="pre">FROM</span> <span class="pre">books;</span></code> 的执行结果有何区别？二者句式有何区别？</p>
<p>发现了吗？上面的 <strong>SELECT</strong> 只输出了我们指定的字段数据，其它字段并没有输出，而且一个完整的 <strong>SELECT</strong> 分成了两行。</p>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>在SQL语法中，一个SQL语句可以分成很多行，一些较为复杂的查询条件，SELECT语句会特别长。此时
为了方便观察，可以把它分割成很多行。无论怎么分割，它还是一个整体，最终要以 <strong>;</strong> 号结尾，
不然命令行还在等待输入，在你按下回车键之前，SQL语句并不会执行。</p>
<img alt="../_images/3-2.png" class="align-center" src="../_images/3-2.png" />
<p>SQL语法中还有两个特殊字符， <strong>\G</strong> 和 <strong>\c</strong>。</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>\G</strong> 会将输出结果以行（row）为单位进行输出，请尝试执行 <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">Title</span> <span class="pre">FROM</span> <span class="pre">books\G</span></code>，再执行 <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">Title</span> <span class="pre">FROM</span> <span class="pre">books;</span></code>。</p></li>
<li><p><strong>\c</strong> 则会终止SQL语句的执行，以此为结尾的SQL语句在按下回车键后并不会执行，请尝试执行 <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">Title</span> <span class="pre">FROM\c</span></code>。</p></li>
</ul>
</div></blockquote>
</div>
<p>试想一下，一个数据库使用了很长时间，里面已经存储了大量数据，一张表就就成千上万行的数据。但如果我只想看其中的一点点数据呢？此时可以使用 <strong>LIMIT</strong> 进行限制：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">books</span><span class="w"> </span><span class="k">LIMIT</span><span class="w"> </span><span class="mi">2</span>
</pre></div>
</div>
<p>这里使用LIMIT限制SELECT的输出，虽然books表里有4条数据，但此时它的查询结果只会输出整张表的前两条数据。那如果我想知道第一行之后的两行数据，该怎么办？ 可以使用如下的 <strong>LIMIT</strong> 条件来达成。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">books</span><span class="w"> </span><span class="k">LIMIT</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>1表示第一行，2表示第一行之后的两行数据，对比 <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">*</span> <span class="pre">FROM</span> <span class="pre">books;</span></code> 的结果，看看是不是这样的呢？</p>
<div class="admonition important">
<p class="admonition-title">重要</p>
<p>不知你是否注意到，截止到止前为止，教程中执行的所有SQL语句，所有的数据库命令相关单词都使用的大写，而表结构、表内数据等则没有特地使用大写？如 <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">*</span> <span class="pre">FROM</span> <span class="pre">books</span> <span class="pre">LIMIT</span> <span class="pre">5;</span></code>。</p>
<p>这是因为在编写SQL时，大家习惯上都使用大写，虽然这不是一个强制要求，也不会影响数据库的SQL执行，但这已然成为了一个行业惯例。而在为数据库和表命名时，都使用小写。字段名（column）表结构则使用如 <a class="reference external" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Camel_case">驼峰命名法</a> 的方法等。</p>
<p>这样就通过大写区分数据库命令，小写区分数据库名、表名，驼峰命名法等区分表结构字段名。</p>
</div>
</section>
<section id="id3">
<h2>选择与排序<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h2>
<p>上一节的 <strong>SELECT</strong> 的查询，无法精确的查找某一条数据，比如 <em>SeriesID</em> 是某个具体值的？这一点在上一章 <a class="reference internal" href="beginner.html#select-where"><span class="std std-ref">删除表中的数据</span></a> 中涉及过，不过此时可以和 <strong>LIMIT</strong> 结合，更精细的在数据中查找数据：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">books</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">SeriesID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">LIMIT</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<img alt="../_images/3-3.png" class="align-center" src="../_images/3-3.png" />
<p><strong>WHERE</strong> 指定了查询条件，同时 <strong>LIMIT</strong> 限制了输出几条结果，如果想要对结果以字母数字的顺序进行排序呢？这时就需要使用 <strong>ORDER BY</strong> 从句了。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">books</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">SeriesID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">Title</span><span class="w"> </span><span class="k">ASC</span><span class="w"> </span><span class="k">LIMIT</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>此时， <strong>SELECT</strong> 语句到了一定量级了，有 <strong>WHERE</strong>、 <strong>ORDER BY</strong>、 <strong>LIMIT</strong> 三个条件，但它们的顺序不能乱，否则数据库会报语法（syntax）错误。</p>
<p>当 <strong>SELECT</strong> 语句执行时，MariaDB以 <strong>WHERE</strong> 为条件输出所有相关数据，然后以 <strong>ORDER BY</strong> 为条件对输出的数据进行排序，最后 <strong>LIMIT</strong> 为条件对结果进行限制输出，因此这三者的前后顺序不能乱，这也是这三个条件这样排序的原因。</p>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>不知你是否注意到 <strong>ASC</strong> 这个flag，它在告诉数据库服务对输出结果进行正序排序，并且ASC是默认的，此处实际上无须带上 <strong>ASC</strong> 这个flag，不过如果我想倒序输出呢？你可以尝试将上面语句中的 <strong>ASC</strong> 改成 <strong>DESC</strong> ，再观察一下输出结果有什么不同。</p>
</div>
<p>上面的例子只是对其中一个字段进行了排序，那如果我想要对多个字段进行排序呢？这也是可以办到的，现在先运行下面的SQL为books这张表再添加几条数据，以便下面的实验结果更加明显。（目前无需理解 <strong>INSERT</strong> 语法，只专注于 <strong>SELECT</strong> 即可）。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">books</span><span class="w"> </span><span class="p">(</span><span class="n">BookID</span><span class="p">,</span><span class="n">Title</span><span class="p">,</span><span class="n">SeriesID</span><span class="p">,</span><span class="n">AuthorID</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span>
<span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;The Trial&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span>
<span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;The Metamorphosis&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span>
<span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="s1">&#39;America&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span>
<span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="s1">&#39;The Castle&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>请使用 <strong>SELECT</strong> 观察一下最新的books表的最新数据，在新加的数据中，AuthorID相同，Title不同，我们就来通过这两个字段再进行排序，请运行以下SQL并观察它们的结果有何不同：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">books</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">SeriesID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">AuthorID</span><span class="w"> </span><span class="k">DESC</span><span class="p">,</span><span class="w"> </span><span class="n">Title</span><span class="w"> </span><span class="k">DESC</span><span class="p">;</span>
<span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">books</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">SeriesID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">AuthorID</span><span class="w"> </span><span class="k">DESC</span><span class="p">,</span><span class="w"> </span><span class="n">Title</span><span class="w"> </span><span class="k">ASC</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p><strong>ORDER BY</strong> 之后可以加多个字段名（column name），每个字段可以分别使用ASC或DESC的flag标记排序方法，然后以 <strong>,</strong> 隔开，就可以做到多字段进行排序，某些情况下这是非常有用的一种技巧。</p>
</div>
</section>
<section id="id4">
<h2>多表查询<a class="headerlink" href="#id4" title="Link to this heading">¶</a></h2>
<p>目前为止，我们所有的查询都只停留在一张表上，但数据库中不止一张表，而且多张表互相之前还会产生关联，这就意味着，如果想要获取一份完整的数据，需要从多张表中同时查询。
例如books中只有书名，作者在另一张authors的表中，books表中只能查到AuthorID，那如果想同时知道书名和作者名，需要同时查询books和authors并将它们关联起来才行。</p>
<p>先来为authors表中添加点数据，请先运行以下SQL（同样无须理解以下语法，只关注于 <strong>SELECT</strong> 即可）：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">authors</span>
<span class="k">ADD</span>
<span class="p">(</span><span class="n">name_last</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span>
<span class="n">name_first</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span>
<span class="n">country</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">));</span>

<span class="k">alter</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">authors</span>
<span class="n">change</span>
<span class="n">id</span><span class="w"> </span><span class="n">AuthorID</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span>

<span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">authors</span>
<span class="p">(</span><span class="n">name_last</span><span class="p">,</span><span class="n">name_first</span><span class="p">,</span><span class="n">country</span><span class="p">)</span>
<span class="k">VALUES</span>
<span class="p">(</span><span class="s1">&#39;Kafka&#39;</span><span class="p">,</span><span class="s1">&#39;Frans&#39;</span><span class="p">,</span><span class="s1">&#39;US&#39;</span><span class="p">),</span>
<span class="p">(</span><span class="s1">&#39;Nicholas&#39;</span><span class="p">,</span><span class="s1">&#39;Sparks&#39;</span><span class="p">,</span><span class="s1">&#39;NL&#39;</span><span class="p">),</span>
<span class="p">(</span><span class="s1">&#39;Stephen&#39;</span><span class="p">,</span><span class="s1">&#39;Kingrks&#39;</span><span class="p">,</span><span class="s1">&#39;AU&#39;</span><span class="p">),</span>
<span class="p">(</span><span class="s1">&#39;ChengEn&#39;</span><span class="p">,</span><span class="s1">&#39;Wu&#39;</span><span class="p">,</span><span class="s1">&#39;CN&#39;</span><span class="p">),</span>
<span class="p">(</span><span class="s1">&#39;NaiAn&#39;</span><span class="p">,</span><span class="s1">&#39;Shi&#39;</span><span class="p">,</span><span class="s1">&#39;CN&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>多表查询需要使用 <strong>JOIN</strong> 从句关键字，比如我们现在要查询books中的书的作者是谁，可以运行以下SQL同时对books和authors进行关联查询：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">Title</span><span class="p">,</span>
<span class="n">CONCAT</span><span class="p">(</span><span class="n">name_first</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">name_last</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">author</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">books</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">authors</span><span class="w"> </span><span class="k">USING</span><span class="w"> </span><span class="p">(</span><span class="n">AuthorID</span><span class="p">)</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">name_first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Frans&#39;</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">Title</span><span class="w"> </span><span class="k">DESC</span>
<span class="k">LIMIT</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>此时，<strong>SELECT</strong> 语句又上升了一个量级，多表查询使得它看起来越发笨重，比起最初的 <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">*</span> <span class="pre">FROM</span> <span class="pre">books;</span></code> ，已然天差地别了。如果你已经跟着教程一步一步学习并理解，这个多表查询也就不足为虑。</p>
<p>多表查询实质上就是增加了 <strong>JOIN</strong> 这一语法从句，它是两个表关联的关键之处。要理解它俩是如何关联的，要先看它俩的表结构：</p>
<img alt="../_images/3-4.png" class="align-center" src="../_images/3-4.png" />
<p>可以观察到两张表都有相同的 <strong>AuthorID</strong> 这个字段名，这就是它们的关联之处。而 <strong>JOIN</strong> 从句中的 <em>USING</em> 就是在表明这两个表要通过 <strong>AuthorID</strong> 关联起来。然而在实际生产环境中，有很多相关联的表格，关联字段名却不一样的情况，这时候关键字 <strong>USING</strong> 就无法适用了，需要改用以下句式：</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>先把authors的字段名AuthorID改回id，模拟真实的生产环境状况：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">authors</span><span class="w"> </span><span class="n">CHANGE</span><span class="w"> </span><span class="n">AuthorID</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span>
</pre></div>
</div>
<p>此时，再使用 <strong>USING</strong> 将会报错，无法进行关联查询。</p>
</div>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">Title</span><span class="p">,</span>
<span class="n">CONCAT</span><span class="p">(</span><span class="n">name_first</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">name_last</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">author</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">books</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">authors</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">AuthorID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">name_first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Frans&#39;</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">Title</span><span class="w"> </span><span class="k">DESC</span>
<span class="k">LIMIT</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>将 <strong>JOIN</strong> 处的关联条件重新更改后，在关联字段名不一致的情况，还是做到了关联查询的效果，更多 <strong>JOIN</strong> 的用法，请参见 <a class="reference external" href="https://mariadb.com/kb/en/join-syntax/">官方文档</a>。</p>
<p>此外，你也应该注意到上方SQL中的 <strong>CONCAT</strong> ，和查询结果中的 <strong>author</strong> ，但在authors表中的字段名却是 <strong>name_first</strong> 和 <strong>name_last</strong> 。 <strong>CONCAT</strong> 是数据库中的字符串函数（string function），它将两个字段 <strong>name_first</strong> 、 <strong>name_last</strong> 和空白字符 <strong>' '</strong> 连接在一起，让查询结果看起来更美观。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在SQL中，字段名不需要用单引号 <strong>'</strong> 引起来，但给予的查询参数要用 <strong>'</strong> 引起来，不然SQL执行时会报错。如上方的 <strong>name_first</strong> 没有用单引号引起来，但是查询参数 <strong>Frans</strong> 却引起来了。</p>
</div>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>你应该注意到，从本小节开始，一大段的SQL语句不再是一行，而是分割成了多行，这更有助于我们的书写和排查语法错误等好处。</p>
</div>
<p>此外，SQL中还支持匹配查询，比如 <strong>Frans</strong> 并不清楚全名或者查找以 <strong>Fra</strong> 开头的值，那可使用 <strong>LIKE</strong> 进行匹配查询：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">Title</span><span class="p">,</span>
<span class="n">CONCAT</span><span class="p">(</span><span class="n">name_first</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">name_last</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">author</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">books</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">authors</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">AuthorID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">name_first</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;Fra%&#39;</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">Title</span><span class="w"> </span><span class="k">DESC</span>
<span class="k">LIMIT</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>以上是两张表联合查询，那要是三张表，或是更多表怎么办？先运行以下sql，为第三张表series填充数据：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span>
<span class="n">series</span>
<span class="k">ADD</span>
<span class="p">(</span><span class="n">isbn</span><span class="w"> </span><span class="nb">CHAR</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span><span class="w"> </span><span class="n">yearPub</span><span class="w"> </span><span class="nb">CHAR</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>

<span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span>
<span class="n">series</span><span class="w"> </span><span class="p">(</span><span class="n">isbn</span><span class="p">,</span><span class="n">yearPub</span><span class="p">)</span>
<span class="k">VALUES</span>
<span class="p">(</span><span class="mi">23592835</span><span class="p">,</span><span class="mi">2021</span><span class="p">),(</span><span class="mi">23453263</span><span class="p">,</span><span class="mi">2020</span><span class="p">),(</span><span class="mi">64323458</span><span class="p">,</span><span class="mi">2022</span><span class="p">);</span>

<span class="k">UPDATE</span><span class="w"> </span><span class="n">books</span>
<span class="k">SET</span><span class="w"> </span><span class="n">SeriesID</span><span class="o">=</span><span class="mi">3</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">BookID</span><span class="o">=</span><span class="mi">7</span><span class="p">;</span>
</pre></div>
</div>
<p>在填充完第三表的数据后，开始联合三张表进行查询：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">Title</span><span class="p">,</span><span class="n">isbn</span><span class="p">,</span>
<span class="n">CONCAT</span><span class="p">(</span><span class="n">name_first</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">name_last</span><span class="p">)</span> <span class="n">AS</span> <span class="n">author</span>
<span class="n">FROM</span> <span class="n">books</span>
<span class="n">JOIN</span> <span class="p">(</span><span class="n">authors</span><span class="p">,</span><span class="n">series</span><span class="p">)</span>
<span class="n">ON</span>
<span class="p">(</span><span class="n">books</span><span class="o">.</span><span class="n">SeriesID</span><span class="o">=</span><span class="n">series</span><span class="o">.</span><span class="n">id</span> <span class="n">AND</span> <span class="n">books</span><span class="o">.</span><span class="n">AuthorID</span><span class="o">=</span><span class="n">authors</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="n">WHERE</span> <span class="n">name_first</span> <span class="n">LIKE</span> <span class="s1">&#39;Fran%&#39;</span>
<span class="n">ORDER</span> <span class="n">BY</span> <span class="n">Title</span> <span class="n">DESC</span>
<span class="n">LIMIT</span> <span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>观察 <strong>JOIN</strong> 相对于上面两张表联合查询时的写法，多张表联合查询时要将多个表放到括号内以 <strong>,</strong> 号隔开，
并在 <strong>ON</strong> 处用括号将这些表与 <strong>FROM</strong> 处的表描述好关联关系，用 <strong>AND</strong> 相连即可。</p>
<p>多多练习 <strong>SELECT</strong> 的联合查询，即便再长的 <strong>SELECT</strong> 查询语句也不足为虑。</p>
</section>
<section id="flag">
<h2>其它有用的flag<a class="headerlink" href="#flag" title="Link to this heading">¶</a></h2>
<section id="id6">
<h3>数据去重<a class="headerlink" href="#id6" title="Link to this heading">¶</a></h3>
<p>在某些情况下，我们会查出一些重复的数据，比如：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">SeriesID</span><span class="p">,</span>
<span class="n">CONCAT</span><span class="p">(</span><span class="n">name_first</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">name_last</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">author</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">books</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">authors</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">AuthorID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">name_first</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;Fra%&#39;</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">Title</span><span class="w"> </span><span class="k">DESC</span><span class="p">;</span>
</pre></div>
</div>
<p>如果不想看到这些重复的数据，那就可以使用 <strong>DISTINCT</strong> 去重，对比以下SQL的查询结果：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="k">DISTINCT</span><span class="w"> </span><span class="n">SeriesID</span><span class="p">,</span>
<span class="n">CONCAT</span><span class="p">(</span><span class="n">name_first</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">name_last</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">author</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">books</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">authors</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">AuthorID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">name_first</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;Fra%&#39;</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">Title</span><span class="w"> </span><span class="k">DESC</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="id7">
<h3>SELECT优先执行<a class="headerlink" href="#id7" title="Link to this heading">¶</a></h3>
<p>在一台繁忙的数据库服务中，SELECT查询操作可能在与修改、更新等操作同步进行，此时，修改和更新会优先于SELECT执行，那如果想要提高SELECT的执行级，可以使用 <strong>HIGH_PRIORITY</strong> 来要求服务器优先响应SELECT的查询：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="k">DISTINCT</span><span class="w"> </span><span class="n">HIGH_PRIORITY</span><span class="w"> </span><span class="n">SeriesID</span><span class="p">,</span>
<span class="n">CONCAT</span><span class="p">(</span><span class="n">name_first</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">name_last</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">author</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">books</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">authors</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">AuthorID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">name_first</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;Fra%&#39;</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">Title</span><span class="w"> </span><span class="k">DESC</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="select-rows">
<h3>计算SELECT查询到的行（rows）数<a class="headerlink" href="#select-rows" title="Link to this heading">¶</a></h3>
<p>在SELECT执行完毕后，系统会临时记录查到到的行数，如：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">SeriesID</span><span class="p">,</span>
<span class="n">CONCAT</span><span class="p">(</span><span class="n">name_first</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">name_last</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">author</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">books</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">authors</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">AuthorID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">name_first</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;Fra%&#39;</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">Title</span><span class="w"> </span><span class="k">DESC</span>
<span class="k">LIMIT</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">FOUND_ROWS</span><span class="p">();</span>
</pre></div>
</div>
<img alt="../_images/3-5.png" class="align-center" src="../_images/3-5.png" />
<p>而 <strong>SQL_CALC_FOUND_ROWS</strong> 则会忽略 <strong>LIMIT</strong> 强制计算找到的行数，如：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">SQL_CALC_FOUND_ROWS</span><span class="w"> </span><span class="n">SeriesID</span><span class="p">,</span>
<span class="n">CONCAT</span><span class="p">(</span><span class="n">name_first</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">name_last</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">author</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">books</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">authors</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">AuthorID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">name_first</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;Fra%&#39;</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">Title</span><span class="w"> </span><span class="k">DESC</span>
<span class="k">LIMIT</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">FOUND_ROWS</span><span class="p">();</span>
</pre></div>
</div>
<p>FOUND_ROWS()记录的值是临时的，只对现在登录的数据库窗口有效，在退出后就消失；多窗口登录的情况下，另一个窗口并不可见，每个窗口即一个连接会话（session）。</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">MariaDB数据库教程</a></h1>








<h3>导航</h3>
<p class="caption" role="heading"><span class="caption-text">教程目录:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">数据库学习环境搭建</a></li>
<li class="toctree-l1"><a class="reference internal" href="beginner.html">快速入门</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">SELECT进阶</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">基础要素</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">选择与排序</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">多表查询</a></li>
<li class="toctree-l2"><a class="reference internal" href="#flag">其它有用的flag</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="beginner.html" title="上一章">快速入门</a></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="提交" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, 程亮.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.4.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="../_sources/newcomer/select.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>